options(stringsAsFactors=FALSE)
suppressPackageStartupMessages(library("argparse"))
library(rlog)
library(rjson)

# create parser object
parser <- ArgumentParser()

# specify our desired options 
# by default ArgumentParser will add an help option 

parser$add_argument("-j", "--json", default=NULL,
                    help="nf schema JSON generated by nf-core python library")
parser$add_argument("-o","--output-xml","--output_xml", default=NULL,
                    help = "output file name for parameters XML file")
parser$add_argument("-t","--strict-mode","--scrict_mode",action="store_true",
                    default=FALSE, help = "include all parameters in XML")
parser$add_argument("-i","--include-hidden-parameters","--include_hidden_parameters",action="store_true",
                    default=FALSE, help = "include all parameters in XML")
parser$add_argument("-n","--nf-core-mode","--nf_core_mode",action="store_true",
                    default=FALSE, help = "flag to indicate nf-core pipeline")
parser$add_argument("-s","--sections-override","--sections_override", default=c("input_output_options"),
                    action="append",help="section in schema JSON file to ensure it's presence in the output XML file")
parser$add_argument("-l","--sections-ignore","--sections_ignore", default=c("Optional_options"),
                    action="append",help="section in schema JSON file to ensure it's presence in the output XML file")
# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults, 
args <- parser$parse_args()

if(!is.null(args$json)){
  nf_params_json = args$json
} else{
  stop(paste("EXITING: Please define a Nextflow Schema JSON file to convert to XML"))
}
#nf_params_json = "/Users/keng/nf-core/sarek/nextflow_schema.json"
sections_ignore = args$sections_ignore
sections_ignore = sections_ignore[sections_ignore!=""]
rlog::log_info(paste("Step0: Reading in",nf_params_json))
json_data = fromJSON(file=nf_params_json)$definitions
generic_data  = fromJSON(file=nf_params_json)$properties
parameter_sections = names(json_data)
rlog::log_info(paste("PARAMETER_SECTIONS:",paste(parameter_sections,collapse=", ")))
params_to_ignore = c("input_paths","tracedir","email")
#####################
returnParamMetadata <- function(param_configuration){
  param_metadata = list()
  #### parameter type
  if("type" %in% names(param_configuration)){
    param_metadata[["type"]] = param_configuration[["type"]]
  } else{
    param_metadata[["type"]] = "string"
  }
  #### help text describing parameter
  description_text = c()
  if("description" %in% names(param_configuration)){
    param_configuration[["description"]] = paste(strsplit(param_configuration[["description"]],"\n")[[1]],collapse="\n")
    #param_configuration[["description"]] = gsub("\n","\\n",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("\"","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("`","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("\\*","-",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("\\*\\*\\NB\\*\\*","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub("&","",param_configuration[["description"]])
    param_configuration[["description"]] = gsub(">","",param_configuration[["description"]])
    description_text = c(description_text,param_configuration[["description"]])
  }
  if("help_text" %in% names(param_configuration)){
    param_configuration[["help_text"]] = paste(strsplit(param_configuration[["help_text"]],"\n")[[1]],collapse="\n")
    param_configuration[["help_text"]] = gsub("\"","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("\\*","-",param_configuration[["help_text"]])
    #param_configuration[["help_text"]] = gsub("\n","\\n",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("`","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub(">","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("\\*\\*\\NB\\*\\*","",param_configuration[["help_text"]])
    param_configuration[["help_text"]] = gsub("&","",param_configuration[["help_text"]])
    description_text = c(description_text,param_configuration[["help_text"]])
  }
  param_metadata[["description"]] = paste(description_text,collapse="\n")
  ### default value
  if("default" %in% names(param_configuration)){
    param_metadata[["default"]] = param_configuration[["default"]]
  } else{
    param_metadata[["default"]] = NULL
  }
  ### list of accepted settings for parameter
  if("list" %in% names(param_configuration)){
    param_metadata[["list"]] = param_configuration[["list"]]
  } else if ("enum" %in% names(param_configuration)){
    param_metadata[["list"]] = param_configuration[["enum"]]
  } else{
    param_metadata[["list"]] = NULL
  }
  return(param_metadata)
}

rlog::log_info(paste("INCLUDE_HIDDEN_PARAMETERS:",args$include_hidden_parameters))
getParams <- function(param_data,include_hidden_parameters=args$include_hidden_parameters,override_list = c(),generic_data,sections_ignore=c()){
  parameterConfigs = list()
  parameter_sections = names(param_data)
  if(length(sections_ignore) >0){
    parameter_sections = parameter_sections[!parameter_sections %in% sections_ignore]
  }
  ########################
  rlog::log_info(paste("Found",length(parameter_sections),"parameter Sections"))
  for(i in 1:length(parameter_sections)){
    rlog::log_info(paste("Starting to parse",parameter_sections[i],"section"))
    allParams = list()
    param_names = names(param_data[[parameter_sections[i]]][["properties"]])
    if(sum(params_to_ignore %in% param_names) > 0){
      #print(!param_names %in% params_to_ignore)
      param_names = param_names[!param_names %in% params_to_ignore]
    }
    rlog::log_info(paste("Found", paste(param_names,collapse=", ")))
    if(!isTRUE(include_hidden_parameters) && !(parameter_sections[i] %in% override_list)){
      rlog::log_info(paste("Checking for required parameters"))
      param_names = NULL
      if("required" %in% names(param_data[[parameter_sections[i]]])){
        if(length(param_data[[parameter_sections[i]]][["required"]]) > 0){
          param_names = param_data[[parameter_sections[i]]][["required"]]
        }
      } 
      if("title" %in% names(param_data[[parameter_sections[i]]])){
        if(grepl("require",param_data[[parameter_sections[i]]][["title"]],ignore.case=T)){
          param_names = names(param_data[[parameter_sections[i]]][["properties"]])
        }
      } else if("description" %in% names(param_data[[parameter_sections[i]]])){
        if(grepl("require",param_data[[parameter_sections[i]]][["description"]],ignore.case=T)){
          param_names = names(param_data[[parameter_sections[i]]][["properties"]])
        }
      } else if(grepl("require",param_data[[parameter_sections[i]]],ignore.case=T)){
        param_names = names(param_data[[parameter_sections[i]]][["properties"]])
      }
    }
    if(!is.null(param_names)){
      for(j in 1:length(param_names)){
        ##cat(paste(param_data[[parameter_sections[i]]][["properties"]][[param_names[j]]]))
        rlog::log_info(paste("Retriving info for parameter",param_names[j]))
        #print(returnParamMetadata(generic_data[[param_names[j]]]))
        param_metadata = returnParamMetadata(param_data[[parameter_sections[i]]][["properties"]][[param_names[j]]])
        ##cat(paste("PARAM_METADATA:",param_metadata))
        allParams[[param_names[j]]] = param_metadata
      }
    } else{
       rlog::log_info(paste("Did not find required parameters to parse in ",parameter_sections[i],"section"))
    }
    print(names(allParams))
    # avoid adding empty lists to our config
    if(length(allParams) > 0){
      parameterConfigs[[parameter_sections[i]]] = allParams  
    } else{
      rlog::log_info(paste("Could not find required parameter names"))
    }
  }
  ### 1st attempt to include parameters from NF pipelines not in nf-core
    rlog::log_info("ADDING_HIDDEN_PARAMETERS")
    param_names = names(generic_data)
    genericParams = list()
    if(!is.null(param_names)){
      for(j in 1:length(param_names)){
        #print(returnParamMetadata(generic_data[[param_names[j]]]))
        genericParams[[param_names[j]]] = returnParamMetadata(generic_data[[param_names[j]]])
      }
    }
    if(length(genericParams) > 0){
      parameterConfigs[["all_options"]] = genericParams  
    }
  return(parameterConfigs)
}
rlog::log_info(paste("Step1: Parsing",nf_params_json))
x = getParams(json_data,override_list = args$sections_override,generic_data =generic_data,sections_ignore = sections_ignore)

### Using the XML package, consider adding nodes to the prefix.xml using newXMLNode():
  
library(XML)

# parse the return object from getParams and retrieves data inputs and returns the remaining contents of getParams
retrieveDataInput <- function(param_configuration){
  param_configuration1 = param_configuration
  is_data_input = c()
  dataInputs = list()
  param_names = names(param_configuration)
  for(i in 1:length(param_names)){
    ##### argument
    if(args$strict_mode){
      if(grepl("Path",param_configuration[[param_names[i]]][["description"]],ignore.case=T) && !grepl("\\*",param_configuration[[param_names[i]]][["description"]])){
        is_data_input = c(is_data_input,param_names[i])
      }
    } else{
      if(grepl("Path",param_configuration[[param_names[i]]][["description"]],ignore.case=T) && !grepl("*",param_configuration[[param_names[i]]][["description"]])){
        is_data_input = c(is_data_input,param_names[i])
      }
    }
  }
  if(length(is_data_input) > 0){
    for(j in 1:length(is_data_input)){
      dataInputs[[is_data_input[j]]] = param_configuration[[is_data_input[j]]]
      param_configuration1[[is_data_input[[j]]]] = NULL
    }
  }
  retrieval_results = list()
  retrieval_results[["dataInputs"]] = dataInputs
  retrieval_results[["params"]] = param_configuration1
  return(retrieval_results)
}
#### convert getParams object into an 'Illumina parameters XML'compatible format
convertParams <- function(parsed_json){
  allParams = list()
  dataInputs = list()
  steps = list()
  for(i in 1:length(names(parsed_json))){
    converted_output = retrieveDataInput(parsed_json[[names(parsed_json)[i]]])
    if(length(converted_output[["params"]]) > 0 ){
      steps[[names(parsed_json)[i]]] = converted_output[["params"]]
    }
    if(length(converted_output[["dataInputs"]]) > 0){
      for(j in 1:length(names(converted_output[["dataInputs"]]))){
        dataInputs[[names(converted_output[["dataInputs"]])[j]]] = converted_output[["dataInputs"]][[names(converted_output[["dataInputs"]])[j]]]
      }
    }
  }
  allParams[["dataInputs"]] = dataInputs
  allParams[["steps"]] = steps
  return(allParams)
}
rlog::log_info(paste("STEP2: Converting JSON to be ready for ICA JSON input form"))
#print(x)
y = convertParams(x)
#print(y)
data_input_configurations = y[["dataInputs"]]
if(args$nf_core_mode){
  ########### workaround add input files --- will not be used by pipeline , but by ICA to stage the data
  if(!"input" %in% names(data_input_configurations) || length(names(data_input_configurations)) == 0){
    data_input_configurations[["input_files"]] = list()
    data_input_configurations[["input_files"]][["description"]] = 'input files for pipeline.\nAll files will be staged in workflow.launchDir'
  }
}

cat(paste("DATA_INPUT_CONFIGURATIONS:",data_input_configurations,"\n"))
#####################
step_configurations = y[["steps"]]
cat(paste("STEP_CONFIGURATIONS:",step_configurations,"\n"))
#stop(paste("STOPPING_NOW!\n"))


convert_json_import_form_types <- function(info_type){
  type_returned = info_type
  if(info_type == "booleanType"){
    type_returned = "CHECKBOX"
  } else if(info_type == "stringType"){
    type_returned = "TEXTBOX"
  } else if(info_type == "doubleType"){
    type_returned = "NUMBER"
  } else if(info_type == "integerType"){
    type_returned = "INTEGER"
  } else if(info_type == "optionsType"){
    type_returned = "SELECT"
  } 
  return(type_returned)
}


create_json_template <- function(data_input_list,parameter_list,file_output){
  template_list = list()
  empty_data_inputs = FALSE
  empty_parameter_list = FALSE
  if(length(names(parameter_list)) < 1){
    rlog::log_warn(paste("Could not find any parameters for template"))
    empty_parameter_list = TRUE
  }
  if(length(names(data_input_list)) < 1){
    rlog::log_warn(paste("Could not find any data inputs for template"))
    empty_data_inputs = TRUE
  }
  template_list[["field-data"]] = data_input_list
  template_list[["field"]] = parameter_list
  if(!empty_parameter_list | !empty_data_inputs){
    template_JSON = jsonlite::toJSON(template_list)
    rlog::log_info(paste("Writing template to",file_output))
    jsonlite::write_json(template_list,path=file_output,pretty=T,auto_unbox=T)
    return(TRUE)
  } else{
    rlog::log_warn(paste("Did not generate template. No parameters or inputs found"))
    rlog::log_warn(paste("EMPTY_DATA_INPUTS:",empty_data_inputs,"EMPTY_PARAMETER_LIST:",empty_parameter_list))
    return(FALSE)
  }
  
}


# BUILD input form
rlog::log_info(paste("STEP3:Generating ICA JSON FORM based off of",nf_params_json))
input_form = list()
#############################
#### add data inputs
rlog::log_info(paste("STEP3a: Adding dataInputs"))
data_input_list_collection = list()
if(length(data_input_configurations) >0){
  section_list = list()
  section_list[["id"]] = "section_datainputs"
  section_list[["type"]] = "SECTION"
  section_list[["label"]] = "Section for selecting data inputs"
  data_input_list_collection[[1]] = section_list
  for(i in 1:length(names(data_input_configurations))){
    input_name = names(data_input_configurations)[i]
    input_list = list()
    input_list[["type"]] = "DATA"
    input_list[["id"]] = input_name
    input_list_required = "true"
    input_list[["label"]] =   data_input_configurations[[input_name]][["label"]]
    input_list_multi_value = "true"
    input_list[["minValues"]] = 0
    input_list[["maxValues"]] = 999
    if(grepl("folder",data_input_configurations[[names(data_input_configurations)[i]]][["description"]],ignore.case=T)){
      input_list[["dataFilter"]] = list()
      input_list[["dataFilter"]][["dataType"]] = list()
      input_list[["dataFilter"]][["dataType"]][["enum"]] = list("directory")
      } else{
      if(names(data_input_configurations)[i]  == "input_files" && data_input_configurations[[names(data_input_configurations)[i]]][["description"]] == 'input files for pipeline.\nAll files will be staged in workflow.launchDir'){
        input_list_required = "false" 
        input_list[["dataFilter"]] = list()
        input_list[["dataFilter"]][["dataType"]] = list()
        input_list[["dataFilter"]][["dataType"]][["enum"]] = list("file")
      } else{
        input_list_required = "true"
        input_list[["dataFilter"]] = list()
        input_list[["dataFilter"]][["dataType"]] = list()
        input_list[["dataFilter"]][["dataType"]][["enum"]] = list("file")
      }
    }
    data_input_configurations[[names(data_input_configurations)[i]]][["description"]] = gsub("\n$","",data_input_configurations[[names(data_input_configurations)[i]]][["description"]])
    input_list[["helpText"]] =  data_input_configurations[[input_name]][["description"]]
    data_input_list_collection[[i+1]] = input_list
  }
} else{
  rlog::log_warn(paste("STEP3a: No dataInputs found"))
}
############## add parameter options
########################
rlog::log_info(paste("STEP3b: Adding parameter options"))
parameter_list_collection = list()
if(length(step_configurations)>0){
  for(i in 1:length(names(step_configurations))){
    section_list = list()
    section_list[["id"]] = paste(names(step_configurations)[i],"section parameters")
    section_list[["type"]] = "SECTION"
    section_list[["label"]] = paste(names(step_configurations)[i],"parameters")
    section_list[["helpText"]] = paste(names(step_configurations)[i],"parameters")
    parameter_list_collection[[i]] = section_list
    parameter_names = names(step_configurations[[names(step_configurations)[i]]])
    for(j in 1:length(parameter_names)){
      parameter_metadata = step_configurations[[names(step_configurations[i])]][[parameter_names[j]]]
     # nested_parameter_node = newXMLNode("parameter",parent=tool_description_node)
      parameter_name = names(step_configurations[[names(step_configurations)[i]]])[j]
      ####################
      field_list = list()
      field_list[["id"]] = parameter_name
      field_list[["helpText"]] = parameter_metadata[["description"]]
      field_list[["label"]] = parameter_name
      field_list_multi_value = "false"
      field_list[["minValues"]] = 0
      field_list[["maxValues"]] = 1
      field_list_default_value = c()
      field_list[["values"]] = list(field_list_default_value)
      #############################################################
      #xmlAttrs(nested_parameter_node) = c(code = parameter_name,minValues = "1",maxValues="1",classification="USER")
      #newXMLNode("label",parameter_names[j],parent=nested_parameter_node)
      #########################
      parameter_metadata[["description"]] = gsub("\n$","",parameter_metadata[["description"]])
      field_list[["helpText"]] =  parameter_metadata[["description"]]
      #### adding options if a list of values are provided
      default_override = FALSE
      if("list" %in% names(parameter_metadata)){
        list_vals = parameter_metadata[["list"]]
        apply_integer_workaround = apply(t(list_vals),2,strtoi)
        if(sum(is.na(apply_integer_workaround)) == 0 ){
          #newXMLNode(paste("integer","Type",sep=""),parent=nested_parameter_node)
          field_list[["type"]] = "INTEGER"
          field_list_default_value = list_vals[1]
          field_list[["values"]] = list(field_list_default_value)
          default_override = TRUE
        } else{
        if(length(list_vals) > 0){
            #options_node = newXMLNode(paste("optionsType"),parent=nested_parameter_node)
            field_list[["type"]] = "SELECT"
            choices = c()
            for(lv in 1:length(list_vals)){
              #newXMLNode("option",list_vals[lv],parent=options_node)
              choices = c(choices,list_vals[lv])
            }
            field_list[["choices"]] = choices
        }
          ##newXMLNode("value",list_vals[1],parent=nested_parameter_node)
          field_list_default_value = list_vals[1]
          field_list[["values"]] = list(field_list_default_value)
          default_override = TRUE
        }
      } else{
        if(grepl("number",parameter_metadata[["type"]],ignore.case = T)){
          if(is.na(as.numeric(parameter_metadata[["default"]]))){
          ###newXMLNode(paste("integer","Type",sep=""),parent=nested_parameter_node)
            field_list[["type"]] = "INTEGER"
          } else{
            field_list[["type"]] = "NUMBER"
          }
        } else{
          field_list[["type"]] = convert_json_import_form_types(paste(parameter_metadata[["type"]],"Type",sep=""))
        }
      }
      if("default" %in% names(parameter_metadata)){
        if(parameter_name != "outdir"){
          dummy_value = ""
        } else{
          dummy_value = "out"
        }
        if(parameter_metadata[["default"]] != ""){
          if(parameter_metadata[["default"]] == FALSE & parameter_metadata[["default"]] != 0){
            parameter_metadata[["default"]] = "false"
          } else if(parameter_metadata[["default"]] == TRUE & parameter_metadata[["default"]] != 1){
            parameter_metadata[["default"]] = "true"
          }
        } else{
          if(parameter_metadata[["type"]] == "boolean"){
            dummy_value = "false"
          } else if(grepl("number",parameter_metadata[["type"]],ignore.case = T)){
            dummy_value = 0
          } else{
            dummy_value = ""
          }
          field_list_default_value = dummy_value
          field_list[["values"]] = list(field_list_default_value)
        }
        if(!default_override){
          field_list_default_value = dummy_value
          field_list[["values"]] = list(field_list_default_value)
        }
      } else{
        dummy_value = ""
        if(parameter_metadata[["type"]] == "boolean"){
          dummy_value = "false"
        } else if(grepl("number",parameter_metadata[["type"]],ignore.case = T)){
          dummy_value = 0
        } else{
          dummy_value = ""
        }
        if(!default_override){
          field_list_default_value = dummy_value
          field_list[["values"]] = list(field_list_default_value)
        }
      }
    if(length(field_list_default_value) > 1){
      field_list[["maxValues"]] = 999
    }
    parameter_list_collection[[j + i]] = field_list
    }
  }
} else{
  rlog::log_warn(paste("STEP3a: No parameters found"))
}
# VIEW XML
#print(doc)

# SAVE XML TO FILE
outputFile = paste(basename(dirname(nf_params_json)), "ica_input_form","json",sep=".")
if(!is.null(args$output)){
  outputPath = args$output
} else{
  outputPath = paste(dirname(nf_params_json),"/",outputFile,sep="")
}
rlog::log_info(paste("STEP4: Generating ICA JSON input form to",outputPath))
#prefix='<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'
#saveXML(doc, file=outputPath,encoding="utf-8")
if(length(parameter_list_collection) > 0 & length(data_input_list_collection) > 0){
  full_collection = c(data_input_list_collection,parameter_list_collection)
} else if(length(parameter_list_collection) > 0 & length(data_input_list_collection) == 0){
  full_collection = parameter_list_collection
} else if(length(parameter_list_collection) == 0 & length(data_input_list_collection) > 0){
  full_collection = data_input_list_collection
} else{
  rlog::log_warn(paste("Did not generate template. No parameters and inputs found"))
  rlog::log_warn(paste("EMPTY_DATA_INPUTS:",length(data_input_list_collection),"EMPTY_PARAMETER_LIST:",length(parameter_list_collection)))
  return(FALSE)
}
for(idx in 1:length(full_collection)){
  print(paste("IDX:",idx,"VAL:",full_collection[idx]))
  input_form[[idx]] = full_collection[[idx]]
}

####### ICA input JSON FORM
input_form_final_list = list()
input_form_final_list[["fields"]] = input_form
input_form_JSON = jsonlite::toJSON(input_form_final_list,pretty=TRUE,auto_unbox=TRUE,flatten = TRUE)
rlog::log_info(paste("Writing input form JSON to",outputPath))
write(input_form_JSON,file=outputPath)


###### create TEMPLATE JSON for ICA CLI generation
file_output = paste(basename(dirname(nf_params_json)), "pipeline.cli_template","json",sep=".")
if(!is.null(args$output)){
  file_output = args$output
} else{
  file_output = paste(dirname(nf_params_json),"/",file_output,sep="")
}
create_json_template(data_input_configurations,step_configurations,file_output)


